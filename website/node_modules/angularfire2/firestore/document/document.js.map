{"version":3,"sources":["../../../../src/firestore/document/document.ts"],"names":[],"mappings":"AACA,OAAO,oBAAoB,CAAC;AAI5B,OAAO,EAAE,UAAU,EAAE,MAAM,uBAAuB,CAAC;AACnD,OAAO,uBAAuB,CAAC;AAK/B,OAAO,EAAE,cAAc,EAAE,MAAM,cAAc,CAAC;AAC9C,OAAO,EAAE,0BAA0B,EAAE,MAAM,0BAA0B,CAAC;AAyBtE;IAOE,kCAAmB,GAAyC;QAAzC,QAAG,GAAH,GAAG,CAAsC;IAAI,CAAC;IAMjE,sCAAG,GAAH,UAAI,IAAO;QACT,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAC5B,CAAC;IAMD,yCAAM,GAAN,UAAO,IAAgB;QACrB,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;IAKD,yCAAM,GAAN;QACE,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;IAC3B,CAAC;IAQD,6CAAU,GAAV,UAAc,IAAY,EAAE,OAAiB;QAC3C,IAAM,aAAa,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC1C,IAAA,2CAAuD,EAArD,YAAG,EAAE,gBAAK,CAA4C;QAC9D,MAAM,CAAC,IAAI,0BAA0B,CAAI,GAAG,EAAE,KAAK,CAAC,CAAC;IACvD,CAAC;IAKD,kDAAe,GAAf;QACE,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAC9B,CAAC;IAKD,+CAAY,GAAZ;QACE,MAAM,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC,GAAG,CAAC,UAAA,MAAM;YACtC,MAAM,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAM,CAAC;QACrE,CAAC,CAAC,CAAC;IACL,CAAC;IACH,+BAAC;AAAD,CA3DA,AA2DC,IAAA","file":"document.js","sourceRoot":"","sourcesContent":["import * as firebase from 'firebase/app';\nimport 'firebase/firestore';\nimport { Observable } from 'rxjs/Observable';\nimport { Subscriber } from 'rxjs/Subscriber';\nimport { QueryFn, AssociatedReference, Action } from '../interfaces';\nimport { fromDocRef } from '../observable/fromRef';\nimport 'rxjs/add/operator/map';\n\nimport { Injectable } from '@angular/core';\nimport { FirebaseApp } from 'angularfire2';\n\nimport { associateQuery } from '../firestore';\nimport { AngularFirestoreCollection } from '../collection/collection';\n\n\n/**\n * AngularFirestoreDocument service\n * \n * This class creates a reference to a Firestore Document. A reference is provided in \n * in the constructor. The class is generic which gives you type safety for data update\n * methods and data streaming.\n * \n * This class uses Symbol.observable to transform into Observable using Observable.from().\n * \n * This class is rarely used directly and should be created from the AngularFirestore service.\n * \n * Example:\n * \n * const fakeStock = new AngularFirestoreDocument<Stock>(firebase.firestore.doc('stocks/FAKE'));\n * await fakeStock.set({ name: 'FAKE', price: 0.01 });\n * fakeStock.valueChanges().map(snap => { \n *   if(snap.exists) return snap.data();\n *   return null;\n * }).subscribe(value => console.log(value));\n * // OR! Transform using Observable.from() and the data is unwrapped for you\n * Observable.from(fakeStock).subscribe(value => console.log(value));\n */\nexport class AngularFirestoreDocument<T> {\n\n  /**\n   * The contstuctor takes in a DocumentReference to provide wrapper methods\n   * for data operations, data streaming, and Symbol.observable.\n   * @param ref \n   */\n  constructor(public ref: firebase.firestore.DocumentReference) { }\n\n  /**\n   * Create or overwrite a single document.\n   * @param data\n   */\n  set(data: T): Promise<void> {\n    return this.ref.set(data);\n  }\n\n  /**\n   * Update some fields of a document without overwriting the entire document.\n   * @param data \n   */\n  update(data: Partial<T>): Promise<void> {\n    return this.ref.update(data);\n  }\n\n  /**\n   * Delete a document.\n   */\n  delete(): Promise<void> {\n    return this.ref.delete();\n  }\n\n  /**\n   * Create a reference to a sub-collection given a path and an optional query\n   * function.\n   * @param path \n   * @param queryFn \n   */\n  collection<T>(path: string, queryFn?: QueryFn): AngularFirestoreCollection<T> {\n    const collectionRef = this.ref.collection(path);\n    const { ref, query } = associateQuery(collectionRef, queryFn);\n    return new AngularFirestoreCollection<T>(ref, query);\n  }\n\n  /**\n   * Listen to snapshot updates from the document.\n   */\n  snapshotChanges(): Observable<Action<firebase.firestore.DocumentSnapshot>> {\n    return fromDocRef(this.ref);\n  }\n\n  /**\n   * Listen to unwrapped snapshot updates from the document.\n   */\n  valueChanges(): Observable<T> {\n    return this.snapshotChanges().map(action => {\n      return (action.payload.exists ? action.payload.data() : null) as T;\n    });\n  }\n}\n"]}